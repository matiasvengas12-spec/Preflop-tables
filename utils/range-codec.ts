import { HANDS_ORDERED_IDS } from '../constants';

/**
 * Encodes a set of selected hand IDs into a compact hexadecimal string.
 * It creates a 169-bit integer where each bit corresponds to a hand in HANDS_ORDERED_IDS.
 * @param selectedHandIds A Set of strings containing the IDs of selected hands.
 * @returns A hexadecimal string representation of the bitmask.
 */
export const encodeRange = (selectedHandIds: Set<string>): string => {
  let bits = 0n;
  HANDS_ORDERED_IDS.forEach((id, index) => {
    if (selectedHandIds.has(id)) {
      bits |= (1n << BigInt(index));
    }
  });
  return bits.toString(16);
};

/**
 * Decodes a hexadecimal string back into an array of hand IDs.
 * @param hexString The hexadecimal string generated by encodeRange.
 * @returns An array of hand IDs corresponding to the selected hands.
 */
export const decodeRange = (hexString: string): string[] => {
  if (!hexString || !/^[0-9a-f]+$/.test(hexString)) {
    return [];
  }
  const bits = BigInt('0x' + hexString);
  const selectedHandIds: string[] = [];
  HANDS_ORDERED_IDS.forEach((id, index) => {
    if ((bits >> BigInt(index)) & 1n) {
      selectedHandIds.push(id);
    }
  });
  return selectedHandIds;
};


/**
 * Encodes a collection of ranges into a single Base64 string.
 * @param ranges A record where keys are range names and values are arrays of hand IDs.
 * @returns A URL-safe Base64 encoded string representing the entire collection.
 */
export const encodeRangeCollection = (ranges: Record<string, string[]>): string => {
    try {
        const compactRanges: Record<string, string> = {};
        for (const [name, hands] of Object.entries(ranges)) {
            compactRanges[name] = encodeRange(new Set(hands));
        }
        const jsonString = JSON.stringify(compactRanges);
        return btoa(jsonString);
    } catch (error) {
        console.error("Failed to encode range collection:", error);
        return '';
    }
}

/**
 * Decodes a Base64 string back into a collection of ranges.
 * @param encodedString The Base64 string generated by encodeRangeCollection.
 * @returns A record where keys are range names and values are arrays of hand IDs.
 */
export const decodeRangeCollection = (encodedString: string): Record<string, string[]> => {
    try {
        const jsonString = atob(encodedString);
        const compactRanges: Record<string, string> = JSON.parse(jsonString);
        const ranges: Record<string, string[]> = {};
        for (const [name, encodedHands] of Object.entries(compactRanges)) {
            ranges[name] = decodeRange(encodedHands);
        }
        return ranges;
    } catch (error) {
        console.error("Failed to decode range collection:", error);
        return {};
    }
}